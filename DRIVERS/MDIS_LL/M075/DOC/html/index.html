<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>MEN - M75 MDIS Driver - Main Page</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Language" content="en, english">
<meta name="Copyright" content="All material copyright MEN Mikro Elektronik GmbH">
<link href="men_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
	<!-- Titel -->
	<img src="menlogo.gif" alt="MEN" style="float: left; height: 103px; width: 155px; margin: 0px;">
	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">M75 MDIS Driver &nbsp; </h1>
	<h3>Main Page</h3>
</div>

<div class="left_to_right">
<!-- Hauptteil -->
	<div class="main">
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindexHL" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>M75 MDIS Driver Documentation</h1>
<p>
This is the documentation of the MDIS low-level driver for the M75 module.<p>
The M75 is a dual HDLC/SDLC communication controller.<p>
This driver provides an MDIS interface for setup of the controller and transmit/receive data in HDLC/SDLC mode. Other synchronous modes and asychronous modes are not supported by this driver.<p>
The driver is valid for M75 hardware Rev. 03 or higher. <br>
 <h2><a name="Variants"></a>
Variants</h2>
The M75 is an A08/D08 M-Module. It can be operated on all M-Module carrier boards. In order to support different CPU/carrier board combinations and to achieve maximum performance, the M75 driver can be built in some variants at compilation time:<p>
<div class="fragment"><pre>
    Driver              Variant Description
    --------            --------------------------------
    Standard            D08 register access, non-swapped
    _sw                 D08 register access, swapped
    </pre></div><p>
Here are some combinations of MEN CPU and carrier boards together with the required variants:<p>
<div class="fragment"><pre>
    CPU                    Carrier Board          Driver Variant
    ----------------       -------------          --------------
    MEN A12  (68k VME)     A201                   Standard
    MEN A12b (68k VME)     onboard slots          _sw
    MEN F7   (PPC CPCI)    F202                   Standard
    </pre></div><p>
<br>
 <h2><a name="BuildDrv"></a>
Build Driver</h2>
The driver is built using the MDIS build environment.<p>
<br>
 <h3><a name="BrkAbrtSw"></a>
Switch M75_SUPPORT_BREAK_ABORT</h3>
This preprocessor switch in the driver(_sw).mak file is selecting whether BREAK/ABORT interrupts should be used. When using this interrupt, some frames may get lost everytime the transmitter or receiver are beeing enabled. But the M75 device will always synchronize again when for example the line is dis- and reconnected or another unnormal status is left.<p>
When not using the BREAK/ABORT interrupt, no frames are lost during normal operation, but therefore the M75 device might loose the synchronisation between data and status FIFO. In this case, the M75 device will return the correct number of received data bytes, but the data of the last frame may partly be attached to the data of the current frame, which , in turn, will not be completely returned.<p>
<br>
 <h2><a name="FuncDesc"></a>
Functional Description</h2>
<br>
 <h3><a name="General"></a>
General</h3>
The driver supports the transmit/receive of data using the hardwares interrupt capabilities.<p>
<br>
 <h4><a name="general_init"></a>
General Setup and Initialization of the driver and hardware</h4>
At opening of the driver the HW and the driver is beeing initialized with default values. (see section about <a class="el" href="m75__drv_8h.html#scc_register_defaults">M75 SCC register defaults</a>) At need this values may be altered (see section about <a class="el" href="m75__drv_8h.html#getstat_setstat_codes">M75 specific Getstat/Setstat standard codes</a>).<p>
For verification purposes, the local loopback mode and auto echo can be enabled (M75_SCC_REG_14)<p>
!!! only change the register bits important to you. Bits not used or declared as reserved must remain as defined in section about <a class="el" href="m75__drv_8h.html#scc_register_defaults">M75 SCC register defaults</a> !!!<p>
<br>
 <h3><a name="channels"></a>
Logical Channels</h3>
Two logical channels are assigned to the two physical communication channels of the M75. Every channel has its own, fully supported set of setup and read registers.<p>
<br>
 <h3><a name="communication"></a>
Communication Principle</h3>
For the user the procedure of receiving data is a follows<ul>
<li>configuration of the M75 HW and driver with different M_setstat calls</li><li>enabling receiver</li><li>waiting for data (using M_getblock (polling) or a signal)</li><li>reading data through M_getblock</li></ul>
<p>
The procedure of data transmission is as follows:<ul>
<li>configuration of the M75 HW and driver with different M_setstat calls</li><li>sending of frames via M_setblock</li></ul>
<p>
<br>
 <h3><a name="receive"></a>
Receive Data</h3>
First, the hardware and driver have to be set up if the communication requirements differ from the default values:<ul>
<li>select front/rear I/O (M75_IO_SEL)</li><li>set parity settings (M75_SCC_REG04),</li><li>set coding method and CRC preset(M75_SCC_REG_10)</li><li>set clock mode (M75_SCC_REG11, source of Rx clock)</li><li>set baudrate (M75_BRGEN_TCONST)</li><li>set Rx buffer queue topology in driver<ul>
<li>maximum frame number (M75_MAX_RXFRAME_NUM)</li><li>maximum frame size (M75_MAX_RXFRAME_SIZE)</li></ul>
</li><li>set timeout for M_getstat call (M75_GETBLOCK_TOUT)</li><li>install Rx signal (M75_SETRXSIG)</li><li>set receiver parameters (M75_SCC_REG03) With the setting of the receiver parameters, the receiver can be enabled and is ready for receiving data. <br>
 </li></ul>
<h4><a name="rx_getblock"></a>
Using M_getblock()</h4>
When no signals are used, M_getblock calls are used to poll driver for received data. If no data is present, the driver waits as set up with M75_GETBLOCK_TOUT and returns with M75_ERR_RX_QEMPTY or ERR_OSS_TIMEOUT if no data is received. If data is received, M_getblock returns the number of bytes received.<p>
<br>
 <h4><a name="rx_sig"></a>
Using Signals</h4>
Using signals, the driver sends a signal each time a frame or an error is received. When an error is received, the first M_getblock, after detection of the error, returns the error code. Subsequent M_getblock calls may pick up already received frames waiting in the Rx queue.<p>
<br>
 <h2><a name="interrupts"></a>
Interrupts</h2>
The driver supports interrupts from the M-Module. The M-Module’s interrupt can not be disabled by the application. Also the interrupt enable registers must not be changed since the interrupt setup is essential for proper function of the driver.<p>
Each Rx interrupt (special condition only) can trigger the following actions:<ul>
<li>if end of frame (EOF) is received:<ul>
<li>put frame into Rx queue of driver</li><li>send a definable user signal to the application.</li><li>wake up waiting M_getblock call.</li></ul>
</li><li>if Rx error (Framing/CRC error, Rx overrun, Parity error) is detected:<ul>
<li>set error flag (returned with waiting or next M_getblock) subsequent M_getblock calls may pick up available frames in Rx queue.</li><li>send a definable user signal to the application.</li><li>wake up waiting M_getblock call.</li><li>no further action (eg. reset FIFOs) is taken. After such an error it is recommended to close the driver and to open it again (performs driver and HW reset).</li></ul>
</li></ul>
<p>
Each Break/Abort interrupt can trigger the following actions:<ul>
<li>set error flag. The next M_getblock is returned with error, following M_getblock calls may pick up available frames in Rx queue.</li><li>reset external FIFO and Status FIFO</li><li>send a definable user signal to the application.</li><li>wake up waiting M_getblock call.</li></ul>
<p>
Each Tx Underrun/EOM interrupt can trigger the following actions:<ul>
<li>transmit next frame if available in Tx queue of driver.</li><li>wake up waiting M_setblock call.</li></ul>
<p>
<br>
 <h2><a name="signals"></a>
Signals</h2>
The driver can send signals to notify the application of received data. The signals must be activated for each channel via the M75_SETRXSIG SetStat code and can be cleared through SetStat M75_CLRRXSIG.<p>
<br>
 <h2><a name="id_prom"></a>
ID PROM</h2>
The M-Module's ID PROM can be checked for validity before the device is initialized. You can set the ID_CHECK option in the device descriptor.<p>
<br>
 <h2><a name="api_functions"></a>
Supported API Functions</h2>
<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td><b>API function</b> </td><td><b>Functionality</b> </td><td><b>Corresponding low level function</b><p>
</td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a4">M_open()</a></td><td>Open device</td><td><a class="el" href="m75__drv_8c.html#a1">M75_Init()</a><p>
</td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a9">M_close()</a> </td><td>Close device  </td><td><a class="el" href="m75__drv_8c.html#a2">M75_Exit()</a>) </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a13">M_setstat()</a> </td><td>Set device parameter  </td><td><a class="el" href="m75__drv_8c.html#a5">M75_SetStat()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a12">M_getstat()</a> </td><td>Get device parameter  </td><td><a class="el" href="m75__drv_8c.html#a6">M75_GetStat()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a14">M_getblock()</a> </td><td>Block read from device  </td><td><a class="el" href="m75__drv_8c.html#a7">M75_BlockRead()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a15">M_setblock()</a> </td><td>Block write from device  </td><td><a class="el" href="m75__drv_8c.html#a8">M75_BlockWrite()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../../LIBSRC/MDIS_API/DOC/html/m__errstr_8c.html#a1">M_errstringTs()</a> </td><td>Generate error message  </td><td>- </td></tr>
</table>
<p>
<br>
 <h2><a name="descriptor_entries"></a>
Descriptor Entries</h2>
The low-level driver initialization routine decodes the following entries ("keys") in addition to the general descriptor keys:<p>
<pre><div>
    Descriptor Entry		Description
    ----------------		-----------
	MAX_RXFRAME_SIZE		maximum Rx frame size (bytes) to be buffered in driver
							Possible values: 0x01 .. 0x800
							default: 0x800
							may be changed with SetStat M75_MAX_RXFRAME_SIZE
	MAX_RXFRAME_NUM			maximum number of Rx frames to be buffered (queue size)
							Possible values: 0x01 ... system limitations
							default: 0x10
							may be changed with SetStat M75_MAX_RXFRAME_NUM
	MAX_TXFRAME_SIZE		maximum Tx frame size (bytes) to be buffered in driver
							Possible values: 0x01 .. 0x800
							default: 0x800
							may be changed with SetStat M75_MAX_TXFRAME_SIZE
	MAX_TXFRAME_NUM			maximum number of Tx frames to be buffered (queue size)
							Possible values: 0x01 ... system limitations
							default: 0x10
							may be changed with SetStat M75_MAX_TXFRAME_NUM
    </pre></div><p>
<br>
 <h2><a name="codes"></a>
M75 specific Getstat/Setstat codes</h2>
see section about <a class="el" href="m75__drv_8h.html#getstat_setstat_codes">Getstat/Setstat codes</a><p>
<br>
 <h2><a name="Documents"></a>
Overview of all Documents</h2>
<h3><a name="m75_simp"></a>
Simple example for using the driver</h3>
<a class="el" href="m75__simp_8c.html">m75_simp.c</a> (see example section)<h3><a name="m75_async"></a>
Simple example for using the driver in async mode</h3>
<a class="el" href="m75__async_8c.html">m75_async.c</a> (see example section)<h3><a name="m75_min"></a>
Minimum descriptor</h3>
m75_min.dsc demonstrates the minimum set of options necessary for using the driver.<h3><a name="m75_max"></a>
Maximum descriptor</h3>
m75_max.dsc shows all possible configuration options for this driver. 
	</div>
</div>

<div class="footer">
<!-- Footer -->
	<p class="footer">
	Generated for M75 MDIS Driver using <a href="http://www.doxygen.org">doxygen</a>.<br>
	Copyright &copy; 2019 <a href="http://www.men.de">MEN Mikro Elektronik GmbH</a>. All Rights Reserved.
	</p>
</div>

</body>
</html>

